โจทย์ข้อนี้เป็นแนว Math ซึ่งสามารถทำได้ 2 วิธี

**วิธีที่ 1 Brute Force**

เริ่มจากการสังเกตว่าตัวเลขที่นำมาตรวจสอบนั้นค่าสูงสุดคือ $10^{8}$ จะเห็นว่าค่ามากที่สุดที่สามารถทำให้ $k > 1$ คือ $10^{4}$ โดยค่าที่มากกว่า $10^{4}$ เมื่อยกกำลัง $2$ แล้วจะมากกว่า $10^{8}$ เสมอ

ดังนั้นเราจะหาจำนวนเต็มบวก $a, b$ ที่ทำให้ $a^{b} = y$ โดยตรวจสอบคู่ (a, b) ทั้งหมดที่เป็นไปได้ เริ่มตั้งแต่ $a = 2, 3, 4, \dots, 10^{4}$ และ $b = 2, 3, \dots$ โดยค่า $a^{b}$ ที่มากกว่า $y$ จะไม่พิจารณาค่า $b$ ที่มากกว่านั้น แล้วพิจารณาค่า $a$ ถัดไป

โดยคำตอบคือค่า $b$ ค่าแรก (ถ้าเราไล่ค่า $a$ จากน้อยไปมาก) ที่ทำให้ $a^{b} = y$ ที่เรารู้ว่าคำตอบคือค่าแรกเพราะถ้าสมมติเราได้คำตอบคือ $2^{20}$ แปลว่านอกจากคำตอบนี้ยังมี $4^{10}$, $32^{4}$, $1024^{2}$ ซึ่งเราต้องการค่า $b$ ที่มากที่สุดก็คือ $20$ จะเห็นว่ายิ่งฐานเลขยกกำลังมาก เลขชี้กำลังจะน้อยลง

วิธีสามารถทำได้เนื่องจากถ้าเราพิจารณา $n\sqrt{y_{max}} = 10^{3} \dots \sqrt{10^{8}} = 10^{7}$ ซึ่งทันใน 1 วินาที 

**วิธีที่ 2 Number Theory**

เนื่องจากจำนวนเต็มบวก $N$ ใดๆ สามารถเขียนในรูปผลคูณของจำนวนเฉพาะได้เสมอหรือก็คือ

$N = p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}} \dots$

โดย $a_{i}$ คือจำนวนเต็มที่ไม่ติดลบและ $p_{i}$ เป็นจำนวนเฉพาะที่ไม่ซ้ำกัน

สังเกตว่าถ้าเราเลือกจำนวนเฉพาะที่มากกว่า $10^{4}$ สองตัวใดๆคูณกันจะมากกว่า $10^{8}$ เสมอดังนั้นตัวเลขที่โจทย์ถามนั้นจะมี 3 แบบ

1. เป็นจำนวนเฉพาะ
2. มีจำนวนเฉพาะที่มากกว่า $10^{4}$ เป็นตัวประกอบเพียงตัวเดียว
3. มีตัวประกอบเฉพาะทั้งหมดน้อยกว่าหรือเท่ากับ $10^{4}$

ซึ่งแบบที่ $1$ และ $2$ จะไม่สามารถจัดให้อยู่ในรูป $a^{b}$ ที่ $b > 1$ ได้ ดังนั้นเราจะหาจำนวนเฉพาะทั้งหมดที่น้อยกว่าหรือเท่ากับ $10^{4}$ โดยใช้ Sieve of Eratosthenes แล้วแยกตัวประกอบ y ให้อยู่ในรูปของ

$y = 2^{a_{1}}3^{a_{2}}5^{a_{3}} \dots 997^{a_{168}}R$

ถ้าเราแยกตัวประกอบให้อยู่ในรูปข้างต้นแล้ว $R$ ไม่เท่ากับ 1 แปลว่าตัวเลขนี้มีจำนวนเฉพาะที่มากกว่า $10^{4}$ เป็นตัวประกอบ แล้วคำตอบของคำถามก็คือ $GCD(a_{1}, a_{2}, a_{3}, \dots, a_{168})$ ถ้าเท่ากับ 1 ก็หมายความว่าตัวเลขนั้นไม่สามารถจัดให้อยู่ในรูป $a^{b}$ เช่นกัน

ที่เราบอกว่าคำตอบคือ GCD เพราะถ้าเรามองจำนวนเฉพาะเป็นของ $1 1 1 1 2 3 3$ เราจะจัดของเป็นกลุ่มกลุ่มละ $k$ ชิ้น (ซึ่งในที่นี้คือเลขชี้กำลัง) โดยที่ของเลขเดียวกันจะอยู่กลุ่มเดียวกันและห้ามมีของเหลือเลย ถามว่า $k$ ที่มากที่สุดคือเท่าไหร่ ปัญหานี้ก็ใช้ GCD ในการแก้เช่นกัน

ในขั้นตอนการหา gcd นั้นอาจเขียน Euclidean Algorithm หรือใช้ Built-in Function อย่าง __gcd (ใน C++) ก็ได้เช่นกัน

#### 
**Solution Code 1**
```cpp
#include <bits/stdc++.h>

using namespace std;
const int bound = 10000;

int main() {
  int n;
  scanf("%d", &n);
  while (n--) {
    long long y;
    bool found = false;
    scanf("%lld", &y);
    for (int i = 2; i <= bound; i++) {
      long long now = i * i, power = i;
      for (int j = 2; j <= 32; j++) {
        if (now == y) {
          printf("%d\n", j);
          found = true;
          break;
        }
        now *= power;
      }
      if (found) {
        break;
      }
    }
    if (!found) {
      printf("NO\n");
    }
  }
}
```

Time Complexity $\mathcal{O}(n\sqrt{y_{max}})$

**Solution Code 2**
```cpp
#include <bits/stdc++.h>

using namespace std;
const int MXN = 1e4 + 1;

vector<bool> notprime(MXN, false);
vector<int> prime;

void sieve() {
  for (int i = 2; i < MXN; i++) {
    if (notprime[i]) {
      continue;
    }
    prime.emplace_back(i);
    for (int j = i * 2; j < MXN; j += i) {
      notprime[j] = 1;
    }
  }
}

int main() {
  int n;
  scanf("%d", &n);
  sieve();
  while (n--) {
    int y, ans = -1;
    scanf("%d", &y);
    for (auto i : prime) {
      if (y % i == 0) {
        int now = 0;
        while (y % i == 0) {
          now++;
          y /= i;
        }
        if (ans == -1) {
          ans = now;
        } else {
          ans = __gcd(ans, now);
        }
      }
    }
    if (y != 1 || ans == 1) {
      printf("NO\n");
    } else {
      printf("%d\n", ans);
    }
  }
}
```

Time Complexity $\mathcal{O}(n\log{}(y_{max}) + \sqrt{y_{max}}\log{}(\sqrt{y_{max}}))$