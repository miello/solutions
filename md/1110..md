เนื่องจากตัวเลขในช่องที่ $1$ ถึง $n$ นั้นมีแค่เลข $1$ ถึง $n$ เท่านั้นและทุกช่องไม่ซ้ำกันอย่างแน่นอน ถ้าให้ตำแหน่งที่ตัวเลข $k$ อยู่คือ $p$ เราจะได้ว่าทุกๆ ลำดับย่อยที่สร้างให้สอดคล้องกับเงือนไขจะมีตำแหน่ง $p$ อยู่ด้วยเสมอ

เราจะนิยาม $val(i)$ ดังนี้

$$
 val(i) = 
  \begin{cases}
   1 & \text{; $x_{i} > k$}   \\
   -1 & \text{; $x_{i} < k$}   \\
   0 & \text{; $x_{i} = k$}
  \end{cases}
$$

ให้ $dp(i)$ เป็นจำนวนตัวเลขที่ต้องการเพื่อที่จะทำให้ $k$ เป็นมัธยฐาน ถ้า $dp(i) > 0$ แปลว่าต้องการตัวเลขที่น้อยกว่า $k$ อีก $dp(i)$ จำนวน แต่ถ้า $dp(i) < 0$ แปลว่าต้องการตัวเลขมากกว่า $k$ อีก $|dp(i)|$ จำนวน (ถ้าสร้างลำดับความยาวเป็นเลขคี่) โดยที่ถ้า $i < p$ หมายถึงพิจารณาตั้งแต่ $i$ ถึง $p - 1$ แต่ถ้า $i > p$ หมายถึงพิจารณาตั้งแต่ $p + 1$ ถึง $i$

$$
 dp(i) = val(i) + 
    \begin{cases}
      dp(i+1) & \text{; i < p}  \\
      dp(i-1) & \text{; i > p}  \\
      0 & \text{; i = p}
    \end{cases}    
$$

โดยเราจะแบ่งพิจารณาเป็นลำดับฝั่งซ้ายของ $p$ ($1 \leq i < p$) และฝั่งขวาของ $p$ ($p < j \leq n$) ซึ่งเราจะสร้างโดยการนำลำดับฝั่งซ้าย (ตั้งแต่ $i$ ถึง $p - 1$), $p$, และลำดับฝั่งขวา (ตั้งแต่ $p + 1$ ถึง $j$ ) มารวมกันซึ่งจะสามารถแยกได้ $4$ แบบ

1. ลำดับฝั่งซ้ายมีความยาวเป็นจำนวนเต็มคู่, ฝั่งขวามีความยาวเป็นจำนวนเต็มคู่, และ $p$
2. ลำดับฝั่งซ้ายมีความยาวเป็นจำนวนเต็มคี่, ฝั่งขวามีความยาวเป็นจำนวนเต็มคี่, และ $p$
3. ลำดับฝั่งซ้ายหรือฝั่งขวาความยาวจำนวนเต็มคู่เพียงข้างเดียว และ $p$ เท่านั้น
4. ตำแหน่ง $p$ อย่างเดียว

(การหาว่าความยาวของลำดับฝั่งซ้ายหรือฝั่งขวาเป็นจำนวนคู่หรือจำนวนคี่ทำได้โดยการพิจารณาค่า $|i - p|$)

**แบบที่ 1 และ 2**: วิธีเหมือนกันคือหาตำแหน่งฝั่งซ้าย $(i)$ และฝั่งขวา $(j)$ ซึ่ง $dp(i) + dp(j) = 0$

**แบบที่ 3**: วิธีคือหาตำแหน่งฝั่งซ้ายหรือขวาซึ่ง $dp(i) = 0$

ซึ่งในแบบที่ $3$ สามารถไล่ทุกช่องใน $dp$ ได้เลย แต่ในแบบที่ $1$ และ $2$ นั้นหากทำตรงๆ จะไม่ทันใน $1$ วินาทีดังนั้นจึงต้องหาวิธีที่เร็วกว่านี้ซึ่งจะอธิบายผ่านเคสตัวอย่างตามที่โจทย์ให้มา

ตัวอย่าง กำหนดให้ $k = 5$ และลำดับเป็น

6 3 9 4 7 **5** 10 8 2 1

ตำแหน่งที่มีค่าเท่ากับ $5$ คือ $6$ และค่าใน $dp(i)$ จะเป็นตามดังนี้

1 0 1 0 1 **0** 1 2 1 0

เราจะพิจารณาฝั่งขวาที่ลำดับความยาวคู่ก่อนโดยจะนับว่าค่า $x_{i}$ มีทั้งหมดกี่ค่า ซึ่งเราจะได้ว่า

- มีช่องที่ $dp(i) = 2$ ทั้งหมด 1 ช่อง (ช่องที่ $8$)
มีช่องที่ $dp(i) = 0$ ทั้งหมด 1 ช่อง (ช่องที่ $10$) 

เมื่อพิจารณาฝั่งซ้ายที่ลำดับความยาวคู่โดยจะได้ตามลำดับดังนี้

- ช่องที่ $4$ ค่า $dp(4) = 0$ ฝั่งขวามีช่องที่ $dp(i) = 0$ ทั้งหมด $1$ ช่องดังนั้นสร้างได้ $1$ ลำดับ
- ช่่องที่ $2$ ค่า $dp(2) = 0$ ฝั่งขวามีช่องที่ $dp(i) = 0$ ทั้งหมด $1$ ช่องดังนั้นสร้างได้ $1$ ลำดับ

ซึ่งในกรณีความยาวคี่ก็ทำในทำนองเดียวกัน

โดยตามที่พิจารณาข้างต้นจะมีกรณีที่ $dp(i) < 0$ ซึ่งเวลานับว่า $dp(i)$ มีทั้งหมดกี่ค่านั้นจะมีปัญหาเนื่องจาก index ของ array นั้นจะมากกว่าหรือเท่ากับ $0$ เสมอ วิธีแก้ปัญหานี้จะมีอยู่ $2$ วิธี 

**วิธีที่ 1** ใช้ `map`, `unordered_map` ในการเก็บค่าที่นับ

**วิธีที่ 2** สร้างค่าใหม่ เช่น ถ้า $dp(i) < 0$ เวลานับให้ไปเพิ่มที่ช่อง $N + |dp(i)|$

## Solution Code

```cpp
#include <bits/stdc++.h>

using namespace std;
const int MXN = 1e6 + 5;
const int CV = 1e6;

long long dp[MXN];
long long temp[2 * MXN];

int main() {
  int n, k, kpos;
  scanf("%d %d", &n, &k);
  for (int i = 0; i < n; i++) {
    int x;
    scanf("%d", &x);
    if (x > k)
      dp[i] = 1;
    else if (x < k)
      dp[i] = -1;
    else
      kpos = i;
  }
  long long ans = 1;
  for (int i = kpos - 1; i >= 0; i--) {
    dp[i] += dp[i + 1];
  }
  for (int i = kpos + 1; i < n; i++) {
    dp[i] += dp[i - 1];
  }
  // Even Case
  for (int i = kpos + 2; i < n; i += 2) {
    if (dp[i] == 0) {
      ans++;
    }
    if (dp[i] > 0) {
      temp[dp[i]]++;
    } else {
      temp[-dp[i] + CV]++;
    }
  }
  for (int i = kpos - 2; i >= 0; i -= 2) {
    if (dp[i] == 0) {
      ans++;
    }
    if (dp[i] >= 0) {
      ans += temp[dp[i] + CV];
    } else {
      ans += temp[-dp[i]];
    }
  }
  fill(temp, temp + 2 * MXN, 0);
  // Odd Case
  for (int i = kpos + 1; i < n; i += 2) {
    if (dp[i] > 0) {
      temp[dp[i]]++;
    } else {
      temp[-dp[i] + CV]++;
    }
  }
  for (int i = kpos - 1; i >= 0; i -= 2) {
    if (dp[i] >= 0) {
      ans += temp[dp[i] + CV];
    } else {
      ans += temp[-dp[i]];
    }
  }
  printf("%lld", ans);
}
```

Time Complexity: $\mathcal{O}(N)$
